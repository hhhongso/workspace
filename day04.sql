-- rank(): 전체 값을 대상으로 순위를 구함. 
-- rank(표현식) within group(order by 표현식): 특정 데이터의 순위를 구함. 
-- rank() over(쿼리 파티션): 쿼리 파티션 내 전체 순위를 구함. 

SELECT RANK(3000) WITHIN GROUP(ORDER BY SALARY DESC) "RANK" FROM EMPLOYEES;
SELECT EMPLOYEE_ID, SALARY, RANK() OVER(ORDER BY SALARY DESC) "RANK" FROM EMPLOYEES; 

SELECT EMPLOYEE_ID, SALARY, DEPARTMENT_ID, FIRST_VALUE(SALARY) OVER(PARTITION BY DEPARTMENT_ID ORDER BY SALARY DESC) "HIGH_SAL_DEPTID" FROM EMPLOYEES;

--Q7                                    --null값을 nvl으로 대체시킨다. 
SELECT EMPLOYEE_ID, LAST_NAME, SALARY, NVL(COMMISSION_PCT,0) as 커미션, TO_CHAR(SALARY*12 + SALARY*12* NVL(COMMISSION_PCT, 0), '$9,999,999') AS 연봉 FROM EMPLOYEES;
--Q8
SELECT EMPLOYEE_ID, LAST_NAME, NVL(MANAGER_ID, 1000) AS 매니저ID FROM EMPLOYEES;

------------------------------------------------------------------------------------------------------------------------------------------------
--Day04
--ex01
SELECT TO_CHAR(TRUNC(AVG(SALARY),0), '9,999,999') AS 사원급여평균 FROM EMPLOYEES;

--ex02
SELECT DEPARTMENT_ID AS 부서코드, TO_CHAR(ROUND(AVG(SALARY),0), 'L99,999.0') AS 부서별급여평균 FROM EMPLOYEES 
GROUP BY DEPARTMENT_ID HAVING AVG(SALARY) > 5000 ORDER BY department_id ASC; 

--ex03
SELECT LAST_NAME, AVG(SALARY) AS 평균급여 FROM EMPLOYEES GROUP BY DEPARTMENT_ID; 
                                                        --error! group by 절에 없는 것을 select 조회할 수 없다. 

--Q1
SELECT JOB_ID, SUM(SALARY) AS 급여합계 FROM EMPLOYEES GROUP BY JOB_ID ORDER BY SUM(SALARY) ASC;

--ex04: 비효율적인 having절. 두번째 방법이 속도가 조금 더 빠르다. 
SELECT DEPARTMENT_ID, MAX(SALARY) AS 최대급여 FROM EMPLOYEES 
GROUP BY DEPARTMENT_ID HAVING DEPARTMENT_ID IN(10, 20) ORDER BY DEPARTMENT_ID ASC;

SELECT DEPARTMENT_ID, MAX(SALARY) AS 최대급여 FROM EMPLOYEES 
WHERE DEPARTMENT_ID IN(10, 20) GROUP BY DEPARTMENT_ID ORDER BY DEPARTMENT_ID ASC;